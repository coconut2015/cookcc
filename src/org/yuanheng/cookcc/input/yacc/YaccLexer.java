/*
 * Copyright (c) 2008-2013, Heng Yuan
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *    Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    Neither the name of the Heng Yuan nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Heng Yuan ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL Heng Yuan BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package org.yuanheng.cookcc.input.yacc;

import java.io.IOException;
import java.io.InputStream;

import java.util.LinkedList;
import java.util.Vector;
import java.util.Stack;

/**
 * @author Heng Yuan
 * @version $Id$
 */
abstract class YaccLexer
{
	protected final static int TOKENTYPE = 256;
	protected final static int TYPE = 257;
	protected final static int TYPEINFO = 258;
	protected final static int TOKEN = 259;
	protected final static int START = 260;
	protected final static int SEPARATOR = 261;
	protected final static int PREC = 262;
	protected final static int PARTIAL_ACTION = 263;
	protected final static int ACTION_CODE = 264;

	protected final static int INITIAL = 0;
	protected final static int SECTION2 = 73;
	protected final static int ACTION = 104;
	protected final static int BLOCKCOMMENT = 117;
	protected final static int CODEINCLUDE = 127;
	protected final static int SECTION3 = 137;

	// an internal class for lazy initiation
	private final static class cc_lexer
	{
		private static char[] accept = ("\000\000\022\001\003\022\022\022\022\022\020\017\001\022\006\000\000\005\000\000\004\002\000\015\000\016\016\016\016\016\016\000\000\021\000\000\000\016\016\016\016\016\016\016\000\000\000\000\000\016\016\016\016\016\016\000\014\000\010\016\016\016\016\014\013\000\016\011\013\007\016\016\012\000\000\022\001\003\022\022\022\022\027\020\025\031\030\000\000\000\004\002\000\021\000\000\000\000\000\000\000\026\000\000\000\000\033\003\033\034\034\025\032\035\033\004\002\000\000\037\003\037\040\040\041\037\036\000\000\043\003\043\044\044\045\043\042\046\046\046\047").toCharArray ();
		private static char[] ecs = ("\000\000\000\000\000\000\000\000\000\001\002\000\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\004\000\005\000\000\006\000\000\000\000\007\010\010\010\010\010\010\010\010\010\010\011\011\012\000\013\000\000\014\014\014\014\014\014\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\000\016\000\000\015\000\017\014\020\014\021\022\023\024\025\015\026\027\015\030\031\032\015\033\034\035\036\015\015\037\040\015\041\011\042\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\043").toCharArray ();
		private static char[][] next = {("\002\003\004\005\006\007\002\010\002\002\011\002\012\012\002\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\002\002\013").toCharArray (), ("\002\014\004\005\015\007\002\010\002\002\011\002\012\012\002\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\002\002\013").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\017\020\000\000\000\021\000\000").toCharArray (), ("\022\022\022\022\022\000\022\022\022\022\022\022\022\022\023\022\022\022\022\022\022\022\022\022\022\022\022\022\022\022\022\022\022\022\022\000").toCharArray (), ("\000\000\000\000\000\000\024\025\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\026\026\026\026\026\026\026\026\026\026\026\027\026\026\026\026\026\026\026\026\026\026\026\026\026\026\026\026\026\026\026\026\026\026\026\000").toCharArray (), ("\000\000\000\000\000\000\000\000\012\000\000\000\012\012\000\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\014\000\000\030\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\016\000\000\000\000\000\000\000\031\031\000\031\031\031\031\031\031\031\031\032\033\031\031\034\035\036\031\031\031\021\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\037\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\040\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\041\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\022\022\000\022\022\022\022\022\042\022\022\022\022\022\022\022\022\022\022\022\022\022\022\022\022\022\022\022\022\022\043\044\022\022\022\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\025\025\000\025\025\025\025\025\025\025\025\025\025\025\025\025\025\025\025\025\025\025\025\025\025\025\025\025\025\025\025\025\025\025\025\000").toCharArray (), ("\026\026\026\026\026\026\026\026\026\026\026\027\026\026\026\026\026\026\026\026\026\026\026\026\026\026\026\026\026\026\026\026\026\026\026\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\031\031\000\031\031\031\031\031\031\031\031\032\033\031\031\034\031\045\031\031\031\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\031\000\000\000\031\031\000\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\031\000\000\000\031\031\000\031\031\046\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\031\000\000\000\031\031\000\031\031\031\031\031\031\031\031\031\031\047\031\031\031\031\031\031\031\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\031\000\000\000\031\031\000\031\031\031\031\031\031\050\031\031\031\031\031\031\031\031\031\031\031\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\031\000\000\000\031\031\000\031\031\031\031\031\031\031\031\031\031\031\031\031\031\051\031\031\031\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\031\000\000\000\031\031\000\031\031\031\031\031\031\031\031\031\031\052\031\031\031\031\031\031\053\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\054\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\055\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\041\000\000\056\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\041\000\000\057\000\000\000\057\000\000\057\057\057\057\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\041\000\000\060\000\000\000\060\000\000\060\060\060\060\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\031\000\000\000\031\031\000\031\031\031\031\031\031\031\031\031\031\052\031\031\031\031\031\031\031\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\031\000\000\000\031\031\000\031\031\031\061\031\031\031\031\031\031\031\031\031\031\031\031\031\031\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\031\000\000\000\031\031\000\031\031\031\031\031\031\031\031\031\062\031\031\031\031\031\031\031\031\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\031\000\000\000\031\031\000\031\031\031\031\063\031\031\031\031\031\031\031\031\031\031\031\031\031\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\031\000\000\000\031\031\000\064\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\031\000\000\000\031\031\000\031\031\031\031\031\031\031\065\031\031\031\031\031\031\031\031\031\031\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\031\000\000\000\031\031\000\031\031\031\031\031\031\031\031\031\031\031\066\031\031\031\031\031\031\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\067\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\070\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\041\000\000\022\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\071\000\000\000\071\000\000\071\071\071\071\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\041\000\000\022\000\000\000\022\000\000\022\022\022\022\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\031\000\000\000\031\031\000\031\031\031\031\031\031\031\031\031\031\031\031\031\031\072\031\031\031\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\031\000\000\000\031\031\000\073\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\031\000\000\000\031\031\000\031\031\031\031\031\074\031\031\031\031\031\031\031\031\031\031\031\031\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\031\000\000\000\031\031\000\031\031\031\031\031\031\031\031\031\031\031\031\075\031\031\031\031\031\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\031\000\000\000\031\031\000\031\031\076\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\031\000\000\000\031\031\000\031\031\077\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\100\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\101\000\000\000\101\000\000\101\101\101\101\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\031\000\000\000\031\031\000\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\031\000\000\000\031\031\000\031\031\031\031\031\031\031\031\031\031\031\031\031\102\031\031\031\031\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\031\000\000\000\031\031\000\031\031\031\031\031\031\031\031\031\031\031\031\031\031\103\031\031\031\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\031\000\000\000\031\031\000\031\031\031\031\031\031\031\031\031\031\031\031\031\031\104\031\031\031\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\031\000\000\000\031\031\000\031\031\031\031\031\031\031\031\031\105\031\031\031\031\031\031\031\031\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\031\000\000\000\031\031\000\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\022\000\000\000\022\000\000\022\022\022\022\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\031\000\000\000\031\031\000\031\031\031\031\031\031\031\031\031\031\031\031\031\106\031\031\031\031\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\031\000\000\000\031\031\000\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\031\000\000\000\031\031\000\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\031\000\000\000\031\031\000\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\031\000\000\000\031\031\000\031\031\031\031\031\031\031\031\031\031\107\031\031\031\031\031\031\031\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\031\000\000\000\031\031\000\031\110\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\031\000\000\000\031\031\000\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\031\000\000\000").toCharArray (), ("\113\114\115\116\117\120\113\121\113\122\113\113\123\123\113\123\123\123\123\123\123\123\123\123\123\123\123\123\123\123\123\123\123\124\113\125").toCharArray (), ("\113\114\115\116\117\120\113\121\113\122\113\113\123\123\113\123\123\123\123\123\123\123\123\123\123\123\123\123\123\123\123\123\123\124\113\125").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\114\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\115\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\126\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000").toCharArray (), ("\130\130\130\130\130\000\130\130\130\130\130\130\130\130\131\130\130\130\130\130\130\130\130\130\130\130\130\130\130\130\130\130\130\130\130\000").toCharArray (), ("\000\000\000\000\000\000\132\133\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\123\000\000\000\123\123\000\123\123\123\123\123\123\123\123\123\123\123\123\123\123\123\123\123\123\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\134\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\135\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\130\130\000\130\130\130\130\130\136\130\130\130\130\130\130\130\130\130\130\130\130\130\130\130\130\130\130\130\130\130\137\140\130\130\130\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\133\133\000\133\133\133\133\133\133\133\133\133\133\133\133\133\133\133\133\133\133\133\133\133\133\133\133\133\133\133\133\133\133\133\133\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\141\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\135\000\000\142\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\135\000\000\143\000\000\000\143\000\000\143\143\143\143\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\135\000\000\144\000\000\000\144\000\000\144\144\144\144\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\145\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\135\000\000\130\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\146\000\000\000\146\000\000\146\146\146\146\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\135\000\000\130\000\000\000\130\000\000\130\130\130\130\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\147\000\000\000\147\000\000\147\147\147\147\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\130\000\000\000\130\000\000\130\130\130\130\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\152\152\153\154\152\155\155\156\152\152\152\152\152\152\152\152\152\152\152\152\152\152\152\152\152\152\152\152\152\152\152\152\152\157\160\161").toCharArray (), ("\152\152\153\154\152\155\155\156\152\152\152\152\152\152\152\152\152\152\152\152\152\152\152\152\152\152\152\152\152\152\152\152\152\157\160\161").toCharArray (), ("\162\162\000\162\162\000\000\000\162\162\162\162\162\162\162\162\162\162\162\162\162\162\162\162\162\162\162\162\162\162\162\162\162\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\162\162\153\162\162\000\000\000\162\162\162\162\162\162\162\162\162\162\162\162\162\162\162\162\162\162\162\162\162\162\162\162\162\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\163\164\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\162\162\000\162\162\000\000\000\162\162\162\162\162\162\162\162\162\162\162\162\162\162\162\162\162\162\162\162\162\162\162\162\162\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\164\164\000\164\164\164\164\164\164\164\164\164\164\164\164\164\164\164\164\164\164\164\164\164\164\164\164\164\164\164\164\164\164\164\164\000").toCharArray (), ("\167\167\170\171\167\167\172\173\167\167\167\167\167\167\167\167\167\167\167\167\167\167\167\167\167\167\167\167\167\167\167\167\167\167\167\174").toCharArray (), ("\167\167\170\171\167\167\172\173\167\167\167\167\167\167\167\167\167\167\167\167\167\167\167\167\167\167\167\167\167\167\167\167\167\167\167\174").toCharArray (), ("\175\175\000\175\175\175\000\000\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\175\175\170\175\175\175\000\000\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\000").toCharArray (), ("\000\000\000\000\000\000\000\176\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\175\175\000\175\175\175\000\000\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\175\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\u0081\u0081\u0082\u0083\u0084\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0085\u0081\u0086").toCharArray (), ("\u0081\u0081\u0082\u0083\u0084\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0081\u0085\u0081\u0086").toCharArray (), ("\u0087\u0087\000\u0087\000\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\000\u0087\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\u0087\u0087\u0082\u0087\000\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\000\u0087\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\u0088\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\u0087\u0087\000\u0087\000\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\u0087\000\u0087\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008c").toCharArray (), ("\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008c").toCharArray (), ("\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\u008b\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray ()};
	}

	// an internal class for lazy initiation
	private final static class cc_parser
	{
		private static char[] rule = ("\000\001\003\002\002\002\000\000\001\001\003\003\002\001\002\002\001\002\001\003\003\003\002\002\000\002\000\002\000\002\000").toCharArray ();
		private static char[] ecs = ("\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\005\006\007\010\011\012\013\014\015").toCharArray ();
		private static char[][] next = {("\000\000\000\000\000\ufffa\ufffa\000\000\ufffa\ufffa\000\000\000\000\001\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\uffff\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\003\004\000\000\005\006\000\000\000\000\000\000\000\007\010\011\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\012\ufff9\000\000\000\000\000\000\000\000\000\000\000\000\013\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\014\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\016\000\000\000\000\000\000\017\000\000\000\000\000\000\000\000\020\000\000\000\000\021\000\022\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\ufffd\ufffd\000\000\ufffd\ufffd\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\ufffc\ufffc\000\000\ufffc\ufffc\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\ufffb\ufffb\000\000\ufffb\ufffb\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\ufff8\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\023\000\000\000\000\000\000\000\000\000\000\000\000\000\000\024\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\023\000\000\000\000\000\000\000\000\000\000\000\000\000\000\025\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\ufff2\ufff2\000\000\ufff2\ufff2\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\uffee\uffee\uffee\uffee\uffee\uffee\uffee\uffee\uffee\uffee\uffee\uffee\uffee\uffee\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\026\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\027\000\000\000\000\000").toCharArray (), ("\ufffe\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\ufff7\030\000\000\000\000\000\000\017\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\031\000\000\000\000\000\000").toCharArray (), ("\ufff0\ufff0\000\000\000\000\000\000\ufff0\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\ufff3\ufff3\000\ufff3\ufff3\ufff3\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\ufff6\ufff6\000\032\ufff6\ufff6\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\ufff5\ufff5\000\032\ufff5\ufff5\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\uffe8\uffe8\000\000\000\uffe8\000\000\uffe8\uffe8\uffe8\000\000\000\000\000\000\000\000\000\000\000\000\033\034\000\000\000").toCharArray (), ("\000\000\000\035\036\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\uffef\uffef\uffef\uffef\uffef\uffef\uffef\uffef\uffef\uffef\uffef\uffef\uffef\uffef\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\ufff1\ufff1\000\000\000\000\000\000\ufff1\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\ufff4\ufff4\000\ufff4\ufff4\ufff4\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\uffea\uffea\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\uffe2\uffe2\000\000\000\037\000\000\040\uffe2\uffe2\000\000\000\000\000\000\000\000\000\000\000\000\000\000\041\000\000").toCharArray (), ("\uffed\uffed\000\000\000\000\000\000\uffed\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\uffe8\uffe8\000\000\000\uffe8\000\000\uffe8\uffe8\uffe8\000\000\000\000\000\000\000\000\000\000\000\000\042\034\000\000\000").toCharArray (), ("\000\000\000\uffe9\uffe9\000\000\000\uffe9\000\000\uffe9\uffe9\uffe9\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\043\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\uffe6\uffe6\000\000\000\000\000\000\000\uffe4\uffe4\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\044\045").toCharArray (), ("\000\000\000\uffeb\uffeb\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\uffe3\uffe3\000\000\000\000\000\000\000\uffe3\uffe3\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\uffec\uffec\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\046\047\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\000\000\000\000\000\000\000\000\000\uffe5\uffe5\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray (), ("\000\000\000\uffe7\uffe7\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000").toCharArray ()};
		private static char[] lhs = ("\000\016\017\020\020\020\020\025\025\021\022\024\027\027\023\026\026\026\026\030\032\031\031\033\033\035\035\036\036\034\034").toCharArray ();
	}

	private final static class YYParserState    // internal tracking tool
	{
		int token;            // the current token type
		Object value;        // the current value associated with token
		int state;            // the current scan state

		YYParserState ()    // EOF token construction
		{
			this (0, null, 0);
		}

		YYParserState (int token, Object value)
		{
			this (token, value, 0);
		}

		YYParserState (int token, Object value, int state)
		{
			this.token = token;
			this.value = value;
			this.state = state;
		}
	}

	// lookahead stack for the parser
	private final LinkedList<YYParserState> _yyLookaheadStack = new LinkedList<YYParserState> ();
	// state stack for the parser
	private final Vector<YYParserState> _yyStateStack = new Vector<YYParserState> (512, 512);

	// flag that indicates error
	private boolean _yyInError;
	// internal track of the argument start
	private int _yyArgStart;
	// for passing value from lexer to parser
	private Object _yyValue;

	private InputStream _yyIs = System.in;
	private byte[] _yyBuffer;
	private int _yyBufferSize = 4096;
	private int _yyMatchStart;
	private int _yyBufferEnd;

	private int _yyBaseState;

	private int _yyTextStart;
	private int _yyLength;

	private Stack<Integer> _yyLexerStack;
	private Stack<Object[]> _yyInputStack;

	// we need to track beginning of line (BOL) status
	private boolean _yyIsNextBOL = true;
	private boolean _yyBOL = true;

	/**
	 * Set the current input.
	 *
	 * @param    is the new input.
	 */
	public void setInput (InputStream is)
	{
		_yyIs = is;
	}

	/**
	 * Obtain the current input.
	 *
	 * @return the current input
	 */
	public InputStream getInput ()
	{
		return _yyIs;
	}

	/**
	 * Switch the current input to the new input.  The old input and already
	 * buffered characters are pushed onto the stack.
	 *
	 * @param    is the new input
	 */
	public void yyPushInput (InputStream is)
	{
		int len = _yyBufferEnd - _yyMatchStart;
		byte[] leftOver = new byte[len];
		System.arraycopy (_yyBuffer, _yyMatchStart, leftOver, 0, len);

		Object[] states = new Object[4];
		states[0] = _yyIs;
		states[1] = leftOver;

		if (_yyInputStack == null)
			_yyInputStack = new Stack<Object[]> ();
		_yyInputStack.push (states);

		_yyIs = is;
		_yyMatchStart = 0;
		_yyBufferEnd = 0;
	}

	/**
	 * Switch the current input to the old input on stack.  The currently
	 * buffered characters are inserted infront of the old buffered characters.
	 */
	public void yyPopInput ()
	{
		Object[] states = _yyInputStack.pop ();
		_yyIs = (InputStream)states[0];
		byte[] leftOver = (byte[])states[1];

		int curLen = _yyBufferEnd - _yyMatchStart;

		if ((leftOver.length + curLen) > _yyBuffer.length)
		{
			byte[] newBuffer = new byte[leftOver.length + curLen];
			System.arraycopy (_yyBuffer, _yyMatchStart, newBuffer, 0, curLen);
			System.arraycopy (leftOver, 0, newBuffer, curLen, leftOver.length);
			_yyBuffer = newBuffer;
			_yyMatchStart = 0;
			_yyBufferEnd = leftOver.length + curLen;
		}
		else
		{
			int start = _yyMatchStart;
			int end = _yyBufferEnd;
			byte[] buffer = _yyBuffer;

			for (int i = 0; start < end; ++i, ++start)
				buffer[i] = buffer[start];
			System.arraycopy (leftOver, 0, buffer, curLen, leftOver.length);
			_yyMatchStart = 0;
			_yyBufferEnd = leftOver.length + curLen;
		}
	}

	/**
	 * Obtain the number of input objects on the stack.
	 *
	 * @return the number of input objects on the stack.
	 */
	public int yyInputStackSize ()
	{
		return _yyInputStack == null ? 0 : _yyInputStack.size ();
	}

	/**
	 * Check whether or not the current token at the beginning of the line.  This
	 * function is not accurate if the user does multi-line pattern matching or
	 * have trail contexts at the end of the line.
	 *
	 * @return whether or not the current token is at the beginning of the line.
	 */
	public boolean isBOL ()
	{
		return _yyBOL;
	}

	/**
	 * Set whether or not the next token at the beginning of the line.
	 *
	 * @param    bol the bol status
	 */
	public void setBOL (boolean bol)
	{
		_yyIsNextBOL = bol;
	}

	/**
	 * Get the current token text.
	 * <p/>
	 * Avoid calling this function unless it is absolutely necessary since it creates
	 * a copy of the token string.  The string length can be found by reading _yyLength
	 * or calling yyLength () function.
	 *
	 * @return the current text token.
	 */
	public String yyText ()
	{
		if (_yyMatchStart == _yyTextStart)        // this is the case when we have EOF
			return null;
		return new String (_yyBuffer, _yyTextStart, _yyMatchStart - _yyTextStart);
	}

	/**
	 * Get the current text token's length.  Actions specified in the CookCC file
	 * can directly access the variable _yyLength.
	 *
	 * @return the string token length
	 */
	public int yyLength ()
	{
		return _yyLength;
	}

	/** Print the current string token to the standard output. */
	public void echo ()
	{
		System.out.print (yyText ());
	}

	/**
	 * Put all but n characters back to the input stream.  Be aware that calling
	 * yyLess (0) is allowed, but be sure to change the state some how to avoid
	 * an endless loop.
	 *
	 * @param    n The number of characters.
	 */
	protected void yyLess (int n)
	{
		if (n < 0)
			throw new IllegalArgumentException ("yyLess function requires a non-zero value.");
		if (n > (_yyMatchStart - _yyTextStart))
			throw new IndexOutOfBoundsException ("yyLess function called with a too large index value " + n + ".");
		_yyMatchStart = _yyTextStart + n;
	}

	/**
	 * Set the lexer's current state.
	 *
	 * @param    baseState the base state index
	 */
	protected void begin (int baseState)
	{
		_yyBaseState = baseState;
	}

	/**
	 * Push the current state onto lexer state onto stack and
	 * begin the new state specified by the user.
	 *
	 * @param    newState the new state.
	 */
	protected void yyPushLexerState (int newState)
	{
		if (_yyLexerStack == null)
			_yyLexerStack = new Stack<Integer> ();
		_yyLexerStack.push (new Integer (_yyBaseState));
		begin (newState);
	}

	/** Restore the previous lexer state. */
	protected void yyPopLexerState ()
	{
		begin (_yyLexerStack.pop ());
	}


	// read more data from the input
	protected boolean yyRefreshBuffer () throws IOException
	{
		if (_yyBuffer == null)
			_yyBuffer = new byte[_yyBufferSize];
		if (_yyMatchStart > 0)
		{
			if (_yyBufferEnd > _yyMatchStart)
			{
				System.arraycopy (_yyBuffer, _yyMatchStart, _yyBuffer, 0, _yyBufferEnd - _yyMatchStart);
				_yyBufferEnd -= _yyMatchStart;
				_yyMatchStart = 0;
			}
			else
			{
				_yyMatchStart = 0;
				_yyBufferEnd = 0;
			}
		}
		else if (_yyBufferEnd == _yyBuffer.length)
		{
			byte[] newBuffer = new byte[_yyBuffer.length + _yyBuffer.length / 2];
			System.arraycopy (_yyBuffer, 0, newBuffer, 0, _yyBufferEnd);
			_yyBuffer = newBuffer;
		}

		int readSize = _yyIs.read (_yyBuffer, _yyBufferEnd, _yyBuffer.length - _yyBufferEnd);
		if (readSize > 0)
			_yyBufferEnd += readSize;
		else if (readSize < 0 && !yyWrap ())        // since we are at EOF, call yyWrap ().  If the return value of yyWrap is false, refresh buffer again
			return yyRefreshBuffer ();
		return readSize >= 0;
	}

	/** Reset the internal buffer. */
	public void yyResetBuffer ()
	{
		_yyMatchStart = 0;
		_yyBufferEnd = 0;
	}

	/**
	 * Set the internal buffer size.  This action can only be performed
	 * when the buffer is empty.  Having a large buffer is useful to read
	 * a whole file in to increase the performance sometimes.
	 *
	 * @param    bufferSize the new buffer size.
	 */
	public void setBufferSize (int bufferSize)
	{
		if (_yyBufferEnd > _yyMatchStart)
			throw new IllegalArgumentException ("Cannot change lexer buffer size at this moment.");
		_yyBufferSize = bufferSize;
		_yyMatchStart = 0;
		_yyBufferEnd = 0;
		if (_yyBuffer != null && bufferSize != _yyBuffer.length)
			_yyBuffer = new byte[bufferSize];
	}

	/**
	 * Reset the internal state to reuse the same parser.
	 * <p/>
	 * Note, it does not change the buffer size, the input buffer, and the input stream.
	 * <p/>
	 * Making this function protected so that it can be enabled only if the child class
	 * decides to make it public.
	 */
	protected void reset ()
	{
		// reset parser state
		_yyLookaheadStack.clear ();
		_yyStateStack.clear ();
		_yyArgStart = 0;
		_yyValue = null;
		_yyInError = false;

		// reset lexer state
		_yyMatchStart = 0;
		_yyBufferEnd = 0;
		_yyBaseState = 0;
		_yyTextStart = 0;
		_yyLength = 0;

		if (_yyLexerStack != null)
			_yyLexerStack.clear ();
		if (_yyInputStack != null)
			_yyInputStack.clear ();

		_yyIsNextBOL = true;
		_yyBOL = true;

	}

	/**
	 * Call this function to start the scanning of the input.
	 *
	 * @return a token or status value.
	 * @throws IOException in case of I/O error.
	 */
	protected int yyLex () throws IOException
	{

		char[] cc_ecs = cc_lexer.ecs;
		char[][] cc_next = cc_lexer.next;
		char[] cc_accept = cc_lexer.accept;

		byte[] buffer = _yyBuffer;

		while (true)
		{
			// initiate variables necessary for lookup
			_yyBOL = _yyIsNextBOL;
			_yyIsNextBOL = false;
			int cc_matchedState = _yyBaseState + (_yyBOL ? 1 : 0);

			int matchedLength = 0;

			int internalBufferEnd = _yyBufferEnd;
			int lookahead = _yyMatchStart;

			int cc_backupMatchedState = cc_matchedState;
			int cc_backupMatchedLength = 0;

			// the DFA lookup
			while (true)
			{
				// check buffer status
				if (lookahead < internalBufferEnd)
				{
					// now okay to process the character
					int cc_toState;
					cc_toState = cc_next[cc_matchedState][cc_ecs[buffer[lookahead] & 0xff]];

					if (cc_toState == 0)
					{
						cc_matchedState = cc_backupMatchedState;
						matchedLength = cc_backupMatchedLength;
						break;
					}

					cc_matchedState = cc_toState;
					++lookahead;
					++matchedLength;

					if (cc_accept[cc_matchedState] > 0)
					{
						cc_backupMatchedState = cc_toState;
						cc_backupMatchedLength = matchedLength;
					}
				}
				else
				{
					int lookPos = lookahead - _yyMatchStart;
					boolean refresh = yyRefreshBuffer ();
					buffer = _yyBuffer;
					internalBufferEnd = _yyBufferEnd;
					lookahead = _yyMatchStart + lookPos;
					if (!refresh)
					{
						// <<EOF>>
						int cc_toState;
						cc_toState = cc_next[cc_matchedState][cc_ecs[256]];
						if (cc_toState != 0)
							cc_matchedState = cc_toState;
						else
						{
							cc_matchedState = cc_backupMatchedState;
							matchedLength = cc_backupMatchedLength;
						}
						break;
					}
				}
			}

			_yyTextStart = _yyMatchStart;
			_yyMatchStart += matchedLength;
			_yyLength = matchedLength;


			switch (cc_accept[cc_matchedState])
			{
				case 1:    // {WS}
				{
					m_this.ignoreWhiteSpace ();
				}
				case 41:
					break;
				case 2:    // '//'.*
				{
					m_this.lineComment ();
				}
				case 42:
					break;
				case 3:    // {NL}
				{
					m_this.newLine ();
				}
				case 43:
					break;
				case 4:    // '/*'
				{
					m_this.blockCommentStart ();
				}
				case 44:
					break;
				case 30:    // '*/'
				{
					m_this.blockCommentEnd ();
				}
				case 70:
					break;
				case 31:    // [^*/\n]+
				{
					m_this.blockCommentContent ();
				}
				case 71:
					break;
				case 32:    // .
				{
					m_this.blockCommentContent ();
				}
				case 72:
					break;
				case 33:    // <<EOF>>
				{
					m_this.blockCommentEof ();
				}
				case 73:
					break;
				case 5:    // '%{'
				{
					m_this.codeIncludeStart ();
				}
				case 45:
					break;
				case 34:    // '%}'
				{
					m_this.codeIncludeEnd ();
				}
				case 74:
					break;
				case 35:    // [^%{\n]+
				{
					m_this.codeIncludeContent ();
				}
				case 75:
					break;
				case 36:    // .
				{
					m_this.codeIncludeContent ();
				}
				case 76:
					break;
				case 37:    // <<EOF>>
				{
					m_this.codeIncludeEof ();
				}
				case 77:
					break;
				case 21:    // '{'
				{
					m_this.actionLB ();
				}
				case 61:
					break;
				case 26:    // '}'
				{
					return m_this.actionRB ();
				}
				case 66:
					break;
				case 27:    // [^'/*{}\n]+
				{
					m_this.actionContent ();
				}
				case 67:
					break;
				case 28:    // .
				{
					m_this.actionContent ();
				}
				case 68:
					break;
				case 29:    // <<EOF>>
				{
					m_this.actionEof ();
				}
				case 69:
					break;
				case 6:    // '%%'
				{
					m_this.startSection2 ();
					return SEPARATOR;
				}
				case 46:
					break;
				case 7:    // ^{OPTWS}%token
				{
					_yyValue = m_this.scanTokenDirective ();
					return TOKENTYPE;
				}
				case 47:
					break;
				case 8:    // ^{OPTWS}%left
				{
					_yyValue = m_this.scanTokenDirective ();
					return TOKENTYPE;
				}
				case 48:
					break;
				case 9:    // ^{OPTWS}%right
				{
					_yyValue = m_this.scanTokenDirective ();
					return TOKENTYPE;
				}
				case 49:
					break;
				case 10:    // ^{OPTWS}%nonassoc
				{
					_yyValue = m_this.scanTokenDirective ();
					return TOKENTYPE;
				}
				case 50:
					break;
				case 11:    // %start
				{
					m_this.scanDirective ();
					return START;
				}
				case 51:
					break;
				case 12:    // %type
				{
					m_this.scanDirective ();
					return TYPE;
				}
				case 52:
					break;
				case 13:    // [<][^>]*[>]
				{
					_yyValue = m_this.scanTypeInfo ();
					return TYPEINFO;
				}
				case 53:
					break;
				case 14:    // ^{OPTWS}%{NAME}
				{
					m_this.unknownDirective ();
				}
				case 54:
					break;
				case 15:    // <<EOF>>
				{
					m_this.earlyEof ();
				}
				case 55:
					break;
				case 16:    // {NAME}
				{
					_yyValue = m_this.parseToken ();
					return TOKEN;
				}
				case 56:
					break;
				case 17:    // [']([^\\']|{ESC})[']
				{
					_yyValue = m_this.parseToken ();
					return TOKEN;
				}
				case 57:
					break;
				case 22:    // %prec
				{
					m_this.scanPrec ();
					return PREC;
				}
				case 62:
					break;
				case 23:    // [:|;]
				{
					return m_this.scanSymbol ();
				}
				case 63:
					break;
				case 24:    // '%%'
				{
					m_this.startSection3 ();
				}
				case 64:
					break;
				case 25:    // <<EOF>>
				{
					return m_this.eof ();
				}
				case 65:
					break;
				case 38:    // (.|\n)*
				{
					m_this.dumpSection3Code ();
				}
				case 78:
					break;
				case 39:    // <<EOF>>
				{
					return m_this.endSection3 ();
				}
				case 79:
					break;
				case 18:    // .
				{
					m_this.invalidChar ();
				}
				case 58:
					break;
				case 19:    // .|\n
				{
					echo ();            // default character action
				}
				case 59:
					break;
				case 20:    // <<EOF>>
				{
					return 0;            // default EOF action
				}
				case 60:
					break;
				default:
					throw new IOException ("Internal error in YaccLexer lexer.");
			}

			// check BOL here since '\n' may be unput back into the stream buffer

			// specifically used _yyBuffer since it could be changed by user
			if (_yyMatchStart > 0 && _yyBuffer[_yyMatchStart - 1] == '\n')
				_yyIsNextBOL = true;
		}
	}


	/**
	 * Call this function to start parsing.
	 *
	 * @return 0 if everything is okay, or 1 if an error occurred.
	 * @throws IOException in case of error
	 */
	@SuppressWarnings ("unchecked")
	public int yyParse () throws IOException
	{
		char[] cc_ecs = cc_parser.ecs;
		char[][] cc_next = cc_parser.next;
		char[] cc_rule = cc_parser.rule;
		char[] cc_lhs = cc_parser.lhs;

		LinkedList<YYParserState> cc_lookaheadStack = _yyLookaheadStack;
		Vector<YYParserState> cc_stateStack = _yyStateStack;
		if (cc_stateStack.size () == 0)
			cc_stateStack.add (new YYParserState ());

		int cc_toState;

		for (; ; )
		{
			YYParserState cc_lookahead;

			int cc_fromState;
			char cc_ch;

			//
			// check if there are any lookahead tokens on stack
			// if not, then call yyLex ()
			//
			if (cc_lookaheadStack.size () == 0)
			{
				_yyValue = null;
				int val = yyLex ();
				cc_lookahead = new YYParserState (val, _yyValue);
				cc_lookaheadStack.add (cc_lookahead);
			}
			else
				cc_lookahead = cc_lookaheadStack.getLast ();

			cc_ch = cc_ecs[cc_lookahead.token];
			cc_fromState = cc_stateStack.get (cc_stateStack.size () - 1).state;
			cc_toState = (short)cc_next[cc_fromState][cc_ch];


			//
			// check the value of toState and determine what to do
			// with it
			//
			if (cc_toState > 0)
			{
				// shift
				cc_lookahead.state = cc_toState;
				cc_stateStack.add (cc_lookahead);
				cc_lookaheadStack.removeLast ();
				continue;
			}
			else if (cc_toState == 0)
			{
				// error
				if (_yyInError)
				{
					// first check if the error is at the lookahead
					if (cc_ch == 1)
					{
						// so we need to reduce the stack until a state with reduceable
						// action is found
						if (_yyStateStack.size () > 1)
							_yyStateStack.setSize (_yyStateStack.size () - 1);
						else
							return 1;    // can't do much we exit the parser
					}
					else
					{
						// this means that we need to dump the lookahead.
						if (cc_ch == 0)        // can't do much with EOF;
							return 1;
						cc_lookaheadStack.removeLast ();
					}
					continue;
				}
				else
				{
					if (yyParseError (cc_lookahead.token))
						return 1;
					_yyLookaheadStack.add (new YYParserState (1, _yyValue));
					_yyInError = true;
					continue;
				}
			}
			_yyInError = false;
			// now the reduce action
			int cc_ruleState = -cc_toState;

			_yyArgStart = cc_stateStack.size () - cc_rule[cc_ruleState] - 1;
			//
			// find the state that said need this non-terminal
			//
			cc_fromState = cc_stateStack.get (_yyArgStart).state;

			//
			// find the state to goto after shifting the non-terminal
			// onto the stack.
			//
			if (cc_ruleState == 1)
				cc_toState = 0;            // reset the parser
			else
			{
				cc_toState = cc_next[cc_fromState][cc_lhs[cc_ruleState]];
			}

			_yyValue = null;

			switch (cc_ruleState)
			{
				case 1:                    // accept
					return 0;
				case 2:    // yacc : section1 SEPARATOR section2
				{
					m_this.parseYacc ();
				}
				case 33:
					break;
				case 3:    // section1 : section1 precedence
				{
					m_this.parseYacc ();
				}
				case 34:
					break;
				case 4:    // section1 : section1 start
				{
					m_this.parseYacc ();
				}
				case 35:
					break;
				case 5:    // section1 : section1 type
				{
					m_this.parseYacc ();
				}
				case 36:
					break;
				case 6:    // section1 :
				{
					m_this.parseYacc ();
				}
				case 37:
					break;
				case 7:    // optTypeInfo :
				{
					m_this.parseYacc ();
				}
				case 38:
					break;
				case 8:    // optTypeInfo : TYPEINFO
				{
					_yyValue = m_this.parseTypeInfo ((java.lang.String)yyGetValue (1));
				}
				case 39:
					break;
				case 9:    // section2 : rules
				{
					m_this.parseYacc ();
				}
				case 40:
					break;
				case 10:    // precedence : TOKENTYPE optTypeInfo tokenList
				{
					m_this.parsePrecedence ((java.lang.String)yyGetValue (1), (java.lang.String)yyGetValue (2), (java.lang.String)yyGetValue (3));
				}
				case 41:
					break;
				case 11:    // type : TYPE TYPEINFO tokenList
				{
					m_this.parseType ((java.lang.String)yyGetValue (2), (java.lang.String)yyGetValue (3));
				}
				case 42:
					break;
				case 12:    // tokenList : tokenList TOKEN
				{
					_yyValue = m_this.parseTokenList ((java.lang.String)yyGetValue (1), (java.lang.String)yyGetValue (2));
				}
				case 43:
					break;
				case 13:    // tokenList : TOKEN
				{
					_yyValue = m_this.parseTokenList ((java.lang.String)yyGetValue (1));
				}
				case 44:
					break;
				case 14:    // start : START TOKEN
				{
					m_this.parseStart ((java.lang.String)yyGetValue (2));
				}
				case 45:
					break;
				case 15:    // rules : rules rule
				{
					m_this.parseRules ();
				}
				case 46:
					break;
				case 16:    // rules : rule
				{
					m_this.parseRules ();
				}
				case 47:
					break;
				case 17:    // rules : rules error
				{
					m_this.parseRuleError ();
				}
				case 48:
					break;
				case 18:    // rules : error
				{
					m_this.parseRulesError ();
				}
				case 49:
					break;
				case 19:    // rule : TOKEN rhsList ';'
				{
					m_this.parseRule ((java.lang.String)yyGetValue (1), (java.util.ArrayList<org.yuanheng.cookcc.doc.RhsDoc>)yyGetValue (2));
				}
				case 50:
					break;
				case 20:    // rhs : terms prec action
				{
					_yyValue = m_this.parseRhsList ((java.lang.String)yyGetValue (1), (java.lang.String)yyGetValue (2), (java.lang.String)yyGetValue (3));
				}
				case 51:
					break;
				case 21:    // rhsList : rhsList '|' rhs
				{
					_yyValue = m_this.parseRhsList ((java.util.ArrayList<org.yuanheng.cookcc.doc.RhsDoc>)yyGetValue (1), (java.lang.Integer)yyGetValue (2), (org.yuanheng.cookcc.doc.RhsDoc)yyGetValue (3));
				}
				case 52:
					break;
				case 22:    // rhsList : ':' rhs
				{
					_yyValue = m_this.parseRhsList ((java.lang.Integer)yyGetValue (1), (org.yuanheng.cookcc.doc.RhsDoc)yyGetValue (2));
				}
				case 53:
					break;
				case 23:    // terms : terms TOKEN
				{
					_yyValue = m_this.parseRHS ((java.lang.String)yyGetValue (1), (java.lang.String)yyGetValue (2));
				}
				case 54:
					break;
				case 24:    // terms :
				{
					_yyValue = m_this.parseTerms ();
				}
				case 55:
					break;
				case 25:    // action : complete_action ACTION_CODE
				{
					_yyValue = m_this.parseAction ((java.lang.String)yyGetValue (2));
				}
				case 56:
					break;
				case 26:    // action :
				{
					_yyValue = m_this.parseAction ();
				}
				case 57:
					break;
				case 27:    // complete_action : complete_action PARTIAL_ACTION
				{
					_yyValue = m_this.parseAction ();
				}
				case 58:
					break;
				case 28:    // complete_action :
				{
					_yyValue = m_this.parseAction ();
				}
				case 59:
					break;
				case 29:    // prec : PREC TOKEN
				{
					_yyValue = m_this.parsePrec ((java.lang.String)yyGetValue (2));
				}
				case 60:
					break;
				case 30:    // prec :
				{
					_yyValue = m_this.parsePrec ();
				}
				case 61:
					break;
				default:
					throw new IOException ("Internal error in YaccLexer parser.");
			}

			YYParserState cc_reduced = new YYParserState (-cc_ruleState, _yyValue, cc_toState);
			_yyValue = null;
			cc_stateStack.setSize (_yyArgStart + 1);
			cc_stateStack.add (cc_reduced);
		}
	}

	/**
	 * This function is used by the error handling grammars to check the immediate
	 * lookahead token on the stack.
	 *
	 * @return the top of lookahead stack.
	 */
	protected YYParserState yyPeekLookahead ()
	{
		return _yyLookaheadStack.getLast ();
	}

	/**
	 * This function is used by the error handling grammars to pop an unwantted
	 * token from the lookahead stack.
	 */
	protected void yyPopLookahead ()
	{
		_yyLookaheadStack.removeLast ();
	}

	/**
	 * Clear the error flag.  If this flag is present and the parser again sees
	 * another error transition, it would immediately calls yyParseError, which
	 * would by default exit the parser.
	 * <p/>
	 * This function is used in error recovery.
	 */
	protected void yyClearError ()
	{
		_yyInError = false;
	}

	/**
	 * This function reports error and return true if critical error occurred, or
	 * false if the error has been successfully recovered.  IOException is an optional
	 * choice of reporting error.
	 *
	 * @param    terminal the terminal that caused the error.
	 * @return true if irrecoverable error occurred.  Or simply throw an IOException.
	 * false if the parsing can be continued to check for specific
	 * error tokens.
	 * @throws IOException in case of error.
	 */
	protected boolean yyParseError (int terminal) throws IOException
	{
		return false;
	}

	/**
	 * Gets the object value associated with the symbol at the argument's position.
	 *
	 * @param    arg the symbol position starting from 1.
	 * @return the object value associated with symbol.
	 */
	protected Object yyGetValue (int arg)
	{
		return _yyStateStack.get (_yyArgStart + arg).value;
	}

	/**
	 * Set the object value for the current non-terminal being reduced.
	 *
	 * @param    value the object value for the current non-terminal.
	 */
	protected void yySetValue (Object value)
	{
		_yyValue = value;
	}


	private final org.yuanheng.cookcc.input.yacc.YaccParser m_this = (org.yuanheng.cookcc.input.yacc.YaccParser)this;

	/**
	 * This function is used to change the initial state for the lexer.
	 *
	 * @param    state the name of the state
	 */
	protected void begin (String state)
	{
		if ("INITIAL".equals (state))
		{
			begin (INITIAL);
			return;
		}
		if ("SECTION2".equals (state))
		{
			begin (SECTION2);
			return;
		}
		if ("ACTION".equals (state))
		{
			begin (ACTION);
			return;
		}
		if ("BLOCKCOMMENT".equals (state))
		{
			begin (BLOCKCOMMENT);
			return;
		}
		if ("CODEINCLUDE".equals (state))
		{
			begin (CODEINCLUDE);
			return;
		}
		if ("SECTION3".equals (state))
		{
			begin (SECTION3);
			return;
		}
		throw new IllegalArgumentException ("Unknown lexer state: " + state);
	}

	/**
	 * Push the current state onto lexer state onto stack and
	 * begin the new state specified by the user.
	 *
	 * @param    state the new state.
	 */
	protected void yyPushLexerState (String state)
	{
		if ("INITIAL".equals (state))
		{
			yyPushLexerState (INITIAL);
			return;
		}
		if ("SECTION2".equals (state))
		{
			yyPushLexerState (SECTION2);
			return;
		}
		if ("ACTION".equals (state))
		{
			yyPushLexerState (ACTION);
			return;
		}
		if ("BLOCKCOMMENT".equals (state))
		{
			yyPushLexerState (BLOCKCOMMENT);
			return;
		}
		if ("CODEINCLUDE".equals (state))
		{
			yyPushLexerState (CODEINCLUDE);
			return;
		}
		if ("SECTION3".equals (state))
		{
			yyPushLexerState (SECTION3);
			return;
		}
		throw new IllegalArgumentException ("Unknown lexer state: " + state);
	}

	/**
	 * Check if there are more inputs.  This function is called when EOF is
	 * encountered.
	 *
	 * @return true to indicate no more inputs.
	 * @throws IOException in case of an IO error
	 */
	protected boolean yyWrap () throws IOException
	{
		if (yyInputStackSize () > 0)
		{
			yyPopInput ();
			return false;
		}
		return true;
	}


/*
 * lexer properties:
 * unicode = false
 * bol = true
 * backup = true
 * cases = 39
 * table = ecs
 * ecs = 36
 * states = 141
 * max symbol value = 256
 *
 * memory usage:
 * full table = 36237
 * ecs table = 5333
 *
 * parser properties:
 * symbols = 31
 * max terminal = 264
 * used terminals = 14
 * non-terminals = 17
 * rules = 30
 * shift/reduce conflicts = 0
 * reduce/reduce conflicts = 0
 *
 * memory usage:
 * ecs table = 1505
 */
}
