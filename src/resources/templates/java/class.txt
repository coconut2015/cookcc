<#macro array a><#list a as i><#if i_index &gt; 0>,</#if>${i}</#list></#macro>
<#macro intarray a><#list a as i>\u${i?hex(4)}</#list></#macro>
<#if package?has_content>
package ${package};
<@array ecs/>
</#if>

import java.io.FileInputStream;
import java.io.InputStream;
import java.io.IOException;

<#if maxSymbol &gt; 257>
import java.io.Reader;
import java.io.InputStreamReader;
</#if>

${header}
<#if public?has_content && public?string == "true">public </#if>class ${ccclass}
{
<#list lexerStates as i>
	protected final static int ${i} = ${lexerBegins[i_index]};
</#list>

	// an internal class for lazy initiation
	private final static class cc_lexer
	{
		private static char[] accept = "<@intarray accepts/>".toCharArray ();
<#if ecs?has_content>
		private static char[] ecs = "<@intarray ecs/>".toCharArray ();
</#if>
<#if table == "full" || table == "ecs">
		private static char[][] next = {<#list dfa as i><#if i_index &gt; 0>,</#if>"<@intarray i/>".toCharArray ()</#list>};
</#if>
	}

<#if maxSymbol &gt; 257>
	private Reader _yyIs;
	private char[] _yyBuffer;
<#else>
	private InputStream _yyIs;
	private byte[] _yyBuffer;
</#if>
	private int _yyBufferSize = 4096;
	private int _yyMatchStart;
	private int _yyBufferEnd;

	private int _yyBaseState;

	private String _yyText = null;
	private int _yyTextStart;
	private int _yyLength;

<#if bol == true>
	// we need to track beginning of line (BOL) status
	private boolean _yyIsNextBOL = true;
	private boolean _yyBOL;
</#if>

<#if maxSymbol &gt; 257>
	public void setInput (Reader reader)
	{
		_yyIs = reader;
	}

	public Reader getInput ()
	{
		return _yyIs;
	}
<#else>
	public void setInput (InputStream is)
	{
		_yyIs = is;
	}

	public InputStream getInput ()
	{
		return _yyIs;
	}
</#if>

<#if bol == true>
	public boolean isBOL ()
	{
		return _yyBOL;
	}
</#if>

	/**
	 * Get the current token text.
	 * <p>
	 * Avoid calling this function unless it is absolutely necessary since it creates
	 * a copy of the token string.  The string length can be found by reading _yyLength
	 * or calling yyLength () function.
	 *
	 * @return	the current text token.
	 */
	public String getText ()
	{
		if (_yyText == null)
			_yyText = new String (_yyBuffer, _yyTextStart, _yyMatchStart - _yyTextStart);
		return _yyText;
	}

	/**
	 * Get the current text token's length.  Actions specified in the CookCC file
	 * can directly access the variable
	 * @return	the string token length
	 */
	public int getLength ()
	{
		return _yyLength;
	}

	/**
	 * Print the current string token to the standard output.
	 */
	public void echo ()
	{
		System.out.print (getText ());
	}

	/**
	 * Set the lexer's current state.
	 *
	 * @param	baseState
	 *			the base state index
	 */
	protected void begin (int baseState)
	{
		_yyBaseState = baseState;
	}

	// read more data from the input
	private boolean yyRefreshBuffer () throws IOException
	{
<#if maxSymbol &gt; 257>
		if (_yyBuffer == null)
			_yyBuffer = new char[_yyBufferSize];
<#else>
		if (_yyBuffer == null)
			_yyBuffer = new byte[_yyBufferSize];
</#if>
		if (_yyMatchStart > 0)
		{
			if (_yyBufferEnd > _yyMatchStart)
			{
				System.arraycopy (_yyBuffer, _yyMatchStart, _yyBuffer, 0, _yyBufferEnd - _yyMatchStart);
				_yyBufferEnd -= _yyMatchStart;
				_yyMatchStart = 0;
			}
			else
			{
				_yyMatchStart = 0;
				_yyBufferEnd = 0;
			}
		}
		int readSize = _yyIs.read (_yyBuffer, _yyBufferEnd, _yyBufferSize - _yyBufferEnd);
		if (readSize > 0)
			_yyBufferEnd += readSize;
		return readSize >= 0;
	}

	/**
	 * Reset the internal buffer.
	 */
	public void resetBuffer ()
	{
		_yyMatchStart = 0;
		_yyBufferEnd = 0;
	}

	/**
	 * Set the internal buffer size.  This action can only be performed
	 * when the buffer is empty.  Having a large buffer is useful to read
	 * a whole file in to increase the performance sometimes.
	 *
	 * @param	bufferSize
	 *			the new buffer size.
	 */
	public void setBufferSize (int bufferSize)
	{
		if (_yyBufferEnd > _yyMatchStart)
			throw new IllegalArgumentException ("Cannot change lexer buffer size at this moment.");
		_yyBufferSize = bufferSize;
		_yyMatchStart = 0;
		_yyBufferEnd = 0;
		if (_yyBuffer != null && bufferSize != _yyBuffer.length)
<#if maxSymbol &gt; 257>
			_yyBuffer = new char[bufferSize];
<#else>
			_yyBuffer = new byte[bufferSize];
</#if>
	}

	/**
	 * Call this function to start the scanning of the input.
	 *
	 * @return	a token or status value.
	 * @throws	IOException
	 *			in case of I/O error.
	 */
	public ${yytype} yyLex () throws IOException
	{
<#if lexerProlog?has_content>
	${lexerProlog}
</#if>

<#if table != "full">
		char[] cc_ecs = cc_lexer.ecs;
</#if>
		char[][] cc_next = cc_lexer.next;
		char[] cc_accept = cc_lexer.accept;

<#if maxSymbol &gt; 257>
		char[] buffer = _yyBuffer;
<#else>
		byte[] buffer = _yyBuffer;
</#if>

		while (true)
		{
			// initiate variables necessary for lookup
<#if bol == true>
			_yyBOL = _yyIsNextBOL;
			_yyIsNextBOL = false;

			int matchedState = _yyBaseState + (_yyBOL ? 1 : 0);
<#else>
			int matchedState = _yyBaseState;
</#if>

			int matchedLength = 0;

			int internalBufferEnd = _yyBufferEnd;
			int lookahead = _yyMatchStart;

			// the DFA lookup
			while (true)
			{
				// check buffer status
				if (lookahead < internalBufferEnd)
				{
					// now okay to process the character
					int currentState;
<#if table == "full">
					currentState = cc_next[matchedState][buffer[lookahead]<#if maxSymbol <= 257>& 0xff</#if>];
<#elseif table == "ecs">
					currentState = cc_next[matchedState][cc_ecs[buffer[lookahead]<#if maxSymbol <= 257>& 0xff</#if>]];
<#else>
					int symbol = cc_ecs[buffer[lookahead]];
					currentState = matchedState;
					while (yylex_check[symbol + yylex_base[currentState]] != currentState)
					{
						currentState = yylex_default[currentState];
						if (currentState >= 18)
							symbol = 0;
					}
					currentState = yylex_next[symbol + yylex_base[currentState]];
</#if>

					if (currentState == 0)
						break;

					matchedState = currentState;
					++lookahead;
					++matchedLength;
				}
				else
				{
					int lookPos = lookahead - _yyMatchStart;
					boolean refresh = yyRefreshBuffer ();
					buffer = _yyBuffer;
					internalBufferEnd = _yyBufferEnd;
					lookahead = _yyMatchStart + lookPos;
					if (! refresh)
					{
						// <<EOF>>
						if (matchedLength == 0)
<#if table == "full">
							matchedState = cc_next[matchedState][${eof}];
<#elseif table == "ecs">
							matchedState = cc_next[matchedState][cc_ecs[${eof}]];
<#else>
</#if>
						break;
					}
				}
			}

			_yyTextStart = _yyMatchStart;
			_yyMatchStart += matchedLength;
			_yyLength = matchedLength;

			switch (cc_accept[matchedState])
			{
<#list lexerCases as i>
<#list i.patterns as p>
				case ${p.caseValue}:
				{
					${i.action}
				}
				case ${p.caseValue + cases + 1}: break;
</#list>
</#list>
				default:
<#if yytype != "void">
					return (${yytype})-1;
<#else>
					return;
</#if>
			}

<#if bol == true>
			// check BOL here since '\n' may be unput back into the stream buffer

			// specifically used _yyBuffer since it could be changed by user
			if (_yyMatchStart > 0 && _yyBuffer[_yyMatchStart - 1] == '\n')
				_yyIsNextBOL = true;
</#if>
		}
	}

<#if main?has_content && main?string == "true">
	/**
	 * This is a stub main function that either reads the file that user specified
	 * or from the standard input.
	 *
	 * @param	args
	 *			command line arguments.
	 *
	 * @throws	Exception
	 *			in case of any errors.
	 */
	public static void main (String[] args) throws Exception
	{
		${ccclass} tmpLexer = new ${ccclass} ();
		if (args.length > 0)
<#if maxSymbol &gt; 257>
			tmpLexer.setInput (new InputStreamReader (FileInputStream (args[0])));
<#else>
			tmpLexer.setInput (new FileInputStream (args[0]));
</#if>

		tmpLexer.yyLex ();
	}
</#if>

<#if code?has_content>
${code}
</#if>

/*
 * properties and statistics
 * bol = ${bol?string}
 * backup = ${backup?string}
 * dfa states = ${dfa?size}
<#if ecs?has_content>
 * ecs = ${dfa[0]?size}
 * eof = ${eof}
 * max symbol value = ${maxSymbol}
</#if>
 */
}