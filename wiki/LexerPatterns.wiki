#summary Description of patterns recognized by the CookCC lexer.

= Patterns =

CookCC follows closely to the [http://dinosaur.compilertools.net/flex/flex_7.html Flex patterns], so this page is mostly a copy/paste of the referenced article.

Some examples can be found in test cases for [http://code.google.com/p/cookcc/source/browse/trunk/tests/nfa/ NFA] and [http://code.google.com/p/cookcc/source/browse/trunk/tests/ccl/ CCL].

|| *Format* || *Description* ||
|| *{{{x}}}* || matches the character *x* ||
|| *{{{.}}}* || matches anything except \n character ||
|| *{{{[xyz]}}}* || a character class which includes *x*, *y*, and *z* ||
|| *{{{[abj-oZ]}}}* || a "character class" with a range in it; matches an `a', a `b', any letter from `j' through `o', or a `Z' ||
|| *{{{[^A-Z]}}}* || a "negated character class", i.e., any character but those in the class. In this case, any character EXCEPT an uppercase letter. ||
|| *{{{[^A-Z\n]}}}* || any character EXCEPT an uppercase letter or a newline ||
|| *{{{r*}}}* || zero or more r's, where a is any regular expression ||
|| *{{{r+}}}* || one or more r's ||
|| *{{{r?}}}* || zero or one r's (that is, "an optional r") ||
|| *{{{r{2,5} }}}* || anywhere from two to five r's ||
|| *{{{r{2,} }}}* || two or more r's ||
|| *{{{r{4} }}}* || exactly 4 r's ||
|| *{{{ {name} }}}* || the expansion of the "shortcut" definition ||
|| *{{{"[xyz]\"foo"}}}* || the literal string: *{{{[xyz]"foo}}}* ||
|| *{{{\x}}}* || if x is an `a', `b', `f', `n', `r', `t', or `v', then the ANSI-C interpretation of \x. Otherwise, a literal `x' (used to escape operators such as *{{{*}}}*) ||
|| *{{{\0}}}* || the character with 0 (ASCII code 0) ||
|| *{{{(r)}}}* || match an r ||
|| *{{{rs}}}* || the concatenation of the regular expression *r* followed by the regular expression *s* ||
|| *{{{r|s}}}* || either an *{{{r}}}* or an *{{{s}}}*. || 
|| *{{{r/s}}}* || *r* followed by *s*, but only obtains the *r* part.  At present, CookCC can only handle cases where either {{{r}}} or {{{s}}} is fixed in length. ||
|| *{{{^r}}}* || an *r* at beginning of line, or the start of scan.  It will increase the DFA size slightly and slightly decrease the lexer performance. || 
|| *{{{r$}}}* || an *r* at the end of the line (\n), but not including the \n character.  Note that this pattern does not work well on files in dos format because it does not consider {{{\r}}} character. ||
|| *{{{<<EOF>>}}}* || an end of file character.  This character is artificial. ||

Escape Characters:
|| *Code* || *Description* ||
|| *{{{\b}}}* || backspace ||
|| *{{{\e}}} || escape {{{\033}}} ||
|| *{{{\f}}}* || form feed ||
|| *{{{\n}}}* || line feed ||
|| *{{{\r}}}* || carriage return ||
|| *{{{\t}}} || tab ||
|| *{{{\s}}} || space {{{' '}}} ||
|| *{{{\\}}}* || back slash (\) ||
|| *{{{\"}}}* || double quote (") ||
|| *{{{\'}}}* || single quote (') ||
|| *{{{\123}}}* || the character with octal value 123 (maximum 3 digits) ||
|| *{{{\x2a}}}* || the character with hexadecimal value 2a (maximum 2 digits) ||
|| *{{{\u002a}}}* || the unicode character with hexadecimal value 2a (exactly 4 digits) ||
Escape sequences with {{{\}}} proceeds any character would treat treat that character as the literal character, rather than special characters.

Additionally, there are predefined POSIX character classes (ASCII only):
|| *Class* || *Equivalent* ||
|| {{{[:alnum:]}}} || {{{[a-zA-Z0-9]}}} ||
|| {{{[:alpha:]}}} || {{{[a-zA-Z]}}} ||
|| {{{[:blank:]}}} || {{{[ \t]}}} ||
|| {{{[:cntrl:]}}} || {{{[\x00-\x1f\x7f]}}} ||
|| {{{[:digit:]}}} || {{{[0-9]}}} ||
|| {{{[:graph:]}}} || {{{[[:alnum:][:punct:]]}}} ||
|| {{{[:lower:]}}} || {{{[a-z]}}} ||
|| {{{[:print:]}}} || {{{[[:graph:] ]}}} ||
|| {{{[:punct:]}}} || {{{[!"#$%&'()*+,-./:;<=>?@[\\\]^_`{|}~]}}} ||
|| {{{[:space:]}}} || {{{[ \t\n\x0b\f\r]}}} ||
|| {{{[:upper:]}}} || {{{[A-Z]}}} ||
|| {{{[:xdigit:]}}} || {{{a-fA-F0-9}}} ||

For example, the following character classes are all equivalent:

|| {{{[[:alnum:]]}}} || {{{[[:alpha:][:digit:]]}}} || {{{[[:alpha:]0-9]}}} || {{{[a-zA-Z0-9]}}} ||

== Character Class Manipulations ==
A character class can be manipulated in several ways:

|| *Operation* || *Description* || *Example* ||
|| {{{ {+} }}} || Merging two character classes. || {{{[A-Z]{+}[a-z]}}} is the same as {{{[A-Za-z]}}} ||
|| {{{ {-} }}} || Remove all characters in the second character class from the first character class || {{{[A-Za-z]{-}[a-z]}}} is the same as {{{[A-Z}}} ||
|| {{{ ^ }}} || Not operation || {{{[[:^alpha:]]}}} is the same as {{{[\0-\xff]{-}[a-zA-Z]}}} ||